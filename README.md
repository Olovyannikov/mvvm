
**SD JS MVVM**

  

**Слайд 1-4 (Введение)**

  

-   Всем привет! Наконец-то мы встретились.
-   ﻿Меня зовут Илья, я пришел из Большого Сбера
-   пишу код в Layer (или как я его ласково называю «Слойка»),
-   организую мероприятия для разработчиков.
-   Если у вас есть желание что-нибудь рассказать на большую аудиторию - пишите, разберемся!  
    

  

**Слайд 5 (План)**

 

-   Итак, сегодня мы поговорим о том - что значит «бизнес-логика», чем она отличается от логики UI, Почему организовывать сложные (или любые) бизнес-процессы в хуках не самая хорошая идея, рассмотрим как можно работать с процессами по-другому и сравним - стало ли лучше.

  

**Слайд 6 (Предисловие)**

  

-   Итак, начну с небольшого вступления.
-   Когда-то я был сторонником хайпового движения за отказ от СТМ. Redux это же сплошной бойлер-плейт, один стор в одном контексте, неявные преобразования данных в селекторах. Зачем оно все, если есть в React уже все необходимое - контексты и хуки, ведь можно организовать поток данных таким образом, чтобы не было больно (спойлер - у всего есть свои ограничения).

  

**Слайд 7 (Предисловие)**

  

-   Потом я столкнулся с реально сложной клиентской логикой (в прошлой команде мы делали реалтайм веб визивиг редактор). Представьте себе - куча функционала, десяток различных ролей (редактор пресс-службы, руководитель, спикер итп), где у каждой роли свой набор функционала.
-   А теперь представьте как такой объем логики бы выглядел в хуках?
-   А вот так (слайд 8)
-   (слайд 9 ) Даже если у вас не такое, казалось бы, сложное приложение, я все равно настоятельно рекомендую попробовать технологии из доклада.
-   Это невероятный буст для вас, как для инженеров.
-   Авторы данных технологий приятные люди и сильные инженеры, которых точно можно слушать и перенимать опыт.
-   Нужно относиться к любой технологии или сообществу без фанатизма

  

**Слайд 10 (предисловие)**

  

-   Хуки - наш дар и наше проклятие. Хуки это естественная часть современного React, но это все-таки логика UI, не бизнес-логика. Просто вдумайтесь, что СТМ сражаются против всего react-hook-мира. Именно эти технологии используют React просто как рисовашку для UI. Эти инструменты дают другой взгляд на проблему при создании наших приложений.

  

**Слайд 11 (предисловие)**

  

-   Современные библиотеки для управления состоянием действительно сложные - reatom, xstate, effector. Возможно, что мир пока не готов к таким технологиям? Надо упростить их api или всем разрабам стать сразу сильнее?
-   Второй поинт, скорее всего, провальный. Порог входа и сложность создания структуры и архитектуры «с нуля», используя дополнительные инструменты вроде этих просто огромна.
-   Начните с простых приложений, чтобы понять как делать стоит, а как нет.
-   Обратитесь к коммьюнити, читайте материалы по данным технологиям. Авторы стараются решить проблему с порогом входа, но авторы зачастую не сильны в написании документации в одиночку, а маркетинг, простота и хайп вокруг чего-то проще просто огромный.

  

**Слайд 12 (предисловие)**

  

-   Скорее всего тебе это нужно! Ведь действительно в приложении с комплексной бизнес-логикой проще поделить на две кучки - вот есть логика, а вот есть UI.
-   Но мир реакта двигался к автономным компонентам или даже к целым автономным блокам.
-   Компонент сам сделает запрос, сам покажет UI и изменения в нем.
-   А как же глобальные данные? Контекст, в котором ты хранишь кэш.
-   Есть действительно сложные кейсы, связанные с рендером реакта. Ну не можем мы генерировать контексты динамически, ведь реакт имеет собственную «систему реактивности» в кавычках.
-   Но внешние сторы запросто решают эту проблему

  

**Слайд 13 (предисловие)**

  

-   Посмотрите по сторонам, например на Vue. Там нет такой проблемы как state management.
-   Забавно наблюдать, как React, реализовав свою систему рендеров, породил целую отдельную сложную ветку под названием «работа с внешним состоянием».
-   Концептуально СТМ это спасение в мире, где все пишут бизнес-логику на инструменте, который должен создавать UI-блоки, но на практике оказывается, что это «сложные технологии», которые вы не хотите видеть на своих проектах, ведь вы не хотите тратить время на обучение себя и сотрудников, переписывать и создавать проекты на технологиях с высоким порогом входа и своей «культурой»
-   Проще и дешевле создавать приложения без них, даже если это инженерно неграматно. Хотя на тех же хуках держать под контролем и писать весь код гораздо, гораааздо сложнее…

  

**Слайд 14 (введение)**

  

-   Бизнес-логика в хуках. Что может пойти не так?
-   Давайте сначала разберемся, что такое БЛ в хуках?

**Слайд 15 (БЛ в хуках)**

  

-   Приведем посмотрим на простое приложение.
-   Есть какой-то компонент, который вызывает какой-то хук;
-   Внутри хука useProducts есть один useEffect, который получает данные и кладет их в локальное хранилище.
-   Довольно простой код, правда?
-   И ведет он себя вполне предсказуемо и понятно, потому что мы так или иначе знакомы с базовыми сущностями React и знаем как императивно работает этот код. Но какие могут быть проблемы?

**Слайд 16 (несогласованный ui)**

  

-   Слышал ли кто-нибудь про «Конкурентный режим» в React?
-   Хорошо, что до этого были доклады про Fiber))
-   Очень много влияния оказывает то, используете ли вы StrictMode или нет, используете ли вы внешние данные за пределами React, как и в каком порядке рендерите компоненты. Если что-то пойдет не так, очень сложно узнать где и когда.

**Слайд 17 (согласованный ui)**

  

-   Для согласованным управлением состоянием появился хук useSyncExternalStore, который используется для обновления состояния приложения всеми современными СТМ.
-   Да, это не просто тупой force render, как это было раньше.

**Слайд 18 (что такое хуки)**

  

-   Итак, давайте разберемся, что же такое хуки в React и для чего они используются.
-   Конечно, пойдем в официальную документацию.

**Слайд 19 (хуки это UI-логика с ограничениями)**

  

-   Самая важная строчка из этого про то, что Хуки это UI-логика с некоторыми ограничениями:
-   Хуки используются только внутри функциональных компонентов React;
-   Хуки вызываются синхронно только на верхнем уровне (безусловно);

**Слайд 20 (А что тогда такое Бизнес-логика)**

-   Что я мог сделать сходу, это пойти в гугл и посмотреть определение там

**Слайд 21 (Бизнес логика это)**

-   Бизнес-логика это совокупность правил, принципов и зависимостей поведения объектов предметной области.
-   Проще говоря - последовательность действий и связь сущностей внутри приложения, которые выполняют конкретно ту роль, для которого создавалось приложение.

**Слайд 22 (сложности при работе с хуками)**

  

-   Почему хуки это не про процессную логику?
-   Первое - приходится постоянно помнить кто кого и зачем рендерит, какой компонент от кого зависит, где и как вызываются перерисовки;

**Слайд 23 (Хуки не были созданы для BLL)**

-   Второе - мы начинаем завязываться на симптомы, а не на реальные события.
-   Чаще всего мы действуем имперически, исходя из наших потребностей и возможностей, а хотелось бы просто указать чего мы хотим и получить результат.

**Слайд 24 (хуки не были созданы для BLL)**

  

-   Тестирование - это отдельная боль. Реально, вы пытались тестировать хуки?
-   Я верю, что все возможно, но зачем столько страданий?
-   Об этом немного позже.

**Слайд 25 (Особенности UI-фреймворка)**

-   Давайте разберемся с первым пунктом. Что означает «держать в голове особенности рендерилки?»

**Слайд 26 (Особенности UI-фреймворка)**

-   Рассмотрим такой пример.
-   Есть какой-то провайдер данных useStructureItemsQuery, есть какой-то стейт с рендер-items, есть useEffect, который обрабатывает useEffect.
-   Надо знать, что в useEffect есть массив зависимостей
-   Надо не забыть подготовить данные, которые приходят из запроса
-   Надо положить данные в хранилище, чтобы было удобно с ними работать и передавать куда-то внутрь нашего приложения.

  

**Слайд 27 (Особенности UI-фреймворка)**

-   Или такой пример
-   Передавать пропсы с данными, а их иногда бывает много
-   А как получаются данные в useUsers? Нам это становится важно, потому что от этого зависит рендер приложения

-   Приходится пристально следить за тем, кто кого рендерит. Меняются фильтры - перерендери все приложение. Меняются данные - тоже перерендери все приложение.
-   Вы скажете - так надо использовать мемы! (слайд 28)

**Слайд 28 (Исправить это можно мемами)**

-   И в целом, вы конечно правы!
-   Ой, не этими мемами (слайд 29)

  

**Слайд 29 (мемы зачеркнуты)**

**Слайд 30-31-32 (а вот этими мемами)**

-   **memo, useMemo, useCallback** делают то, что нам нужно, но какой ценой?
-   Кто точно знает как работает useMemo?

**Слайд 33 (тестирование)**

-   Отдельная песня это тестирование.
-   Если нам надо тестировать бизнес-процесс, то зачем нам рендерить компонент?
-   А как правильно тестировать хуки со сложной логикой?
-   Все возможно, но опять же - какой ценой? ﻿

**Слайд 34 (тестируем код, а не логику)**

  

-   Получается, что мы больше тестируем то, как наш код работает, вместо того, чтобы тестировать важные бизнес-процессы; ﻿

**Слайд 35 - 36 (Что делать, если надо просто тестировать логику? Отдай QA)**

**Слайд 37 (Завязываемся на симптомы)**

-   Очень часто мы оперируем вещами, которые не созданы для того или иного функционала. Как пример

**Слайд 38 (Завязываемся на симптомы)**

-   Что не так в этом коде?
-   Получили асинхронно данные на загрузку страницы, сложили их в state и пользуемся дальше;
-   Но ведь маунт компонента и загрузка страницы не одно и тоже событие

  

**Слайд 39**

-   Этот код делает тоже самое, только скрывает от вас весь бардак под красивое API;

**Слайд 40 (выделяем в отдельный слой)**

-   И все это время мы писали код внутри View-слоя приложения;
-   Завязывались на Жизненный цикл компонента;
-   Тестировали код, а не процесс;
-   Давайте попробуем выделить Модель с данными и посмотрим как это повлияет на наш DX;

**Слайд 41 (дисклеймер)**

-   Сегодня я буду показывать примеры на библиотеке Effector, потому что я ее очень люблю, являюсь контрибьютором этой библиотеки и она изначально создавалась для описания бизнес-логики;
-   Все эти примеры можно описать с помощью любого аналогичного инструмента, будь то Mobx, Xstate, RxJS, Reatom или даже Redux (с некоторыми допущениями);

**Слайд 42 (Effector)**

-   Итак, эффектор говорит - пиши бизнес-логику с легкостью

**Слайд 43 (БЛ)**

-   Даже в документации приводится описание того, что подразумевается под разделением БЛ от UI-логики;
-   Читать со слайда

**Слайд 44-45-46 (Базовые Юниты)**

-   Итак, давайте проговорим какие у нас есть базовые юниты. Такие юниты есть в любом СТМ, отличаются лишь названия и, может быть, смысл.
-   Ивент
-   Эффект
-   Стор

**Слайд 47 (Опишем приложение в отдельном слое)**

-   Давайте посмотрим как наше приложение выглядит теперь?
-   Сверху вниз
-   Есть событие «нажатие на кнопку»
-   Есть сайд-эффект (например асинхронная валидация на бэкенде);
-   Есть хранилище кликов, стор
-   И есть стор, который содержит булевое значение - есть ли ошибка при валидации или нет;
-   Сэмпл - это маленький участок какого-либо бизнес-процесса, в нашем случае их тут два:
-   Первый сэмпл говорит - «если нажали на кнопку, то возьми данные из clicksCount, передай их в validateClickFx и запусти эффект»
-   Второй сэмпл говорит - «если validateClickFx закончился, то возьми clicksCount, увеличь текущее значение на 1 и положи получившееся значение обратно в clicksCount»

**Слайд 48 (привязки к UI)**

-   Как теперь выглядит наш интерфейс?
-   Сильно проще и нагляднее.
-   Есть четкие границы, где заканчивается БЛ и начинается UI.
-   Нет лишних триггеров для «случайного» ре-рендера компонентов.

**Слайд 49 (усложним пример)**

-   Есть такой код. Он в целом неплохой и достаточно читаемый.
-   Но что, если появятся дополнительные связи и зависимости?

  

**Слайд 50 (Еще усложним пример)**

-   Теперь у нас есть какая-то панелька, например Сайдбар, который показывается по условию.
-   Да, код тут очень притянут, но это всего лишь пример;
-   Условие - показать панель, если счетчик больше 10
-   Подписываемся в useEffect на счетчик и устанавливаем булевое значение в стейт showPanel, если выполняется условие;
-   При этом каждое обновление стейта со счетчиком или панелью триггерит рендер компонента и всех детей, независимо от того - зависимы они от данных или нет (например <Chart/>);

**Слайд 51 (Опишем фичу в модели)**

-   Теперь вынесем этот функционал в отдельный слой;
-   При этом модель для Панельки может переиспользоваться в другом месте, независимо от текущего бизнес-процесса;
-   В сэмпле опишем - «если clicksCount изменился И значение > 10, то вызови событие openPanel»
-   Ну красота!

**Слайд 52 (Привяжем логику к UI)**

-   Теперь видно, что каждый компонент обладает только той логикой, которая нужна ему в моменте
-   Нет лишних триггеров для рендеров
-   Зависимости на уровне моделей

**Слайд 53 (MVVM)**

-   Самые внимательные заметили, что это на самом деле MVVM;
-   MVVM это почти про любое клиентское приложение, где есть какая-то логика
-   Есть модель, где описана Логика приложения
-   Есть вьюшка, где отображается интерфейс (например наша верстка)
-   И есть тонкая прослойка между моделью и вьюшкой - view-model;

**Слайд 54 (С особенностями разобрались)**

-   С особенностями рендера разобрались, теперь это уже не так важно
-   А что с «симптоматикой»?

**Слайд 55 (Правила хуков)**

-   давайте еще раз вспомним для чего нужны хуки
-   для ui-логики

**Слайд 56 (симптомы - useEffect)**

  

-   useEffect хороший инструмент для синхронизации локальных состояний
-   Но просто отвратительный для управления сложными бизнес-процессами;
-   В этом примере мы хотим при попадании на страницу Page запросить данные и положить их в стейт, чтобы дальше куда-то передать. ﻿

**Слайд 57 (перестаем искать useEffect)**  

  

-   Хорошо, но для такой логики есть другие инструменты
-   Например событие перехода на конкретный маршрут
-   Это просто более логично, чем рендер определенного компонента
-   В этом примере в конфиге React Router’a просто вызовем какое-то событие в поле loader.

**Слайд 58 (loader -> model)**

  

-   а после этого в модели можем обрабатывать это событие так, как нам необходимо;

**Слайд 59 (тестирование это легко)**

-   тестировать бизнес-логику отдельно от UI становится как никогда просто
-   Определяем скоуп, вызываем события или эффекты, получаем ожидаемый результат! Изи!
-   А верстку оставьте скриншотным тестам…

**Слайд 60 (ПРОЦЕССЫ)**

-   Хахха. Вы могли заметить, что в моем докладе 63 раза звучало слово «Процесс», и это не спроста!)

**Слайд 61 (Зависимость)**

-   Теперь мы запросто можем видеть систему целиком, в отрыве от View-слоя, легко можем масштабировать и управлять этой системой

  

**Слайд 62 (Зависимость)**

  

-   Теперь, если нам надо сделать зависимость одного компонента системы от другого,

**Слайд 63 (Зависимость)**

-   То сделать это будет проще простого

**Слайд 64 (Точно ли стало лучше?)**

**Слайд 65 (КРУД)**

-   Если ваше приложение это просто набор CRUD-операций, то скорее всего вам хватит простого React-Query и простейшей логики в компонентах
-   Но если ваше приложение содержит какие-то более-менее процессы (а оно скорее всего содержит), то стоит задуматься над тем, чтобы вынести эту логику в отдельный слой. Авторизация, корзина товаров, покупка, чат и его инициализация, текстовый редактор итп;

**Слайд 66 (бойлерплейт)**

-   Конечно, есть некоторый налог на удобство - это создание кучи сущностей для описания всего процесса
-   Создать ивент, эффект, стор, описать связи…

  

**Слайд 67 (Утилиты)**

-   конечно, в любой библиотеке есть уже целая куча утилитарных вспомогательных функций, оберток, и всевозможных конструкций

**Слайд 68 (Утилиты)**

-   Для effector и асинхронных запросов - farfetched, в redux есть целый toolkit, в mobx есть mobx-state-tree и так далее;

  

Выводы:

  

-   Мало кода !== хороший код. Если ваша «зиро депенденси» политика кажется вам хорошей идеей, то дважды подумайте о том, как ваше приложение будет расти;
-   Если ваше приложение нечто больше, чем КРУД-мешалка, то самое время выделить отдельный слой для логики;
-   Инструменты призваны упростить вашу жизнь. Если удобен DX, то будет лучше и UX. Меньше багов, проще дебаг, лучше перформанс и все остальное;
-   Не бойтесь СТМ, времена «старого редакса» уже прошли. Сейчас на рынке стейт-менеджеров все сильно лучше. Каждый может найти действительно хороший инструмент, который покроет ваши потребности.

  

Спасибо! :)
